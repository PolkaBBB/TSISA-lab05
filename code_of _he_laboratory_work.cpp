
// вариант №3

#include <iostream>
#include <random>
#include <vector>
#include <algorithm>

const int N = 24; // ккол-во дискретных значений в наборе (из варианта)

// создаём вектор пар, в который будем записывать набор экспериментальных данных вида {x,t}
std::vector<std::pair<double, double>> function(24);

// метод, возвращающий сумму квадратов ошибок всех N точек
double recurssion_function(double C, double D) {
	double sum_E = 0;
	for (int i = 0; i < N; i++) { // для вектора пар от 0 до 23 значений
		double x = function[i].first; // устанавливаем в паре "х" первой координатой
		double t = function[i].second; // устанавливаем в паре "t" второй координатой
		double y = C * x + D; // считаем значение нашей y(x) нашей линейной зависимости
		sum_E = sum_E + pow((y - t), 2); // считаем сумму квадратов ошибок для всех точек
	}
	return sum_E;
}

// метод, определяющий коэффициент "С" с помощью прямого пассивного поиска
double Method_Passive_Search() {
    // задаём длинну интервала неопределённости, по достижению котрой коэффициент "С" считается найденным
    const double eps = 0.01;
    double e = 1.; // текущая ошибка кнкретной точки
    double now_C; // текущий коэффициент "С"
    double C = 0.; // переменная для записи коэффициента "С"
    double min_possible_C = pow(10, 200); // заведомо большое число, с которым будет сравниваться искомый коэффициент "С"
    double iterator = 1.; // счётчик
    const double C_max = 1.; // значение определённое самим, исходя из варианта
    const double C_min = -1.; // значение определённое самим, исходя из варианта
    while (e > eps) { // пока заведомо большая ошибка данной точки не достигла отметки 0,01, то делаем:
        for (int m = 0; m < (iterator + 1.); m++) {
            // вычисляем коэффициент "С" на текущей итерации (формула из методички)
            now_C = (((C_max - C_min) * m) / (N - 1.)) + C_min;
            // если суммарная ошибка квадратов всех точек с таким коэффициентом "С" меньше заведомо огромной ошибки, то:
            if (recurssion_function(now_C, 0.) < min_possible_C) { 
                // меняем заведомо огромную ошибку на суммарную ошибку квадратов всех точек для дальнейшего сравнения
                min_possible_C = recurssion_function(now_C, 0.);
                // "удачный" коэффициент "С" записываем 
                C = now_C;
            }
        }
        e = (C_max - C_min) / (iterator + 1.); // меняем величину текущей ошибки
        iterator++; // увеличиваем счётчик
    }
    return C;
}

// метод, определяющий коэффициент "D" с помощью метода дихотомии
double Method_dihotomia(double a, double b, double C) { // подаём на вход 3 параметра: длинну отрезка [a,b] и коэффициент "С"
    // задаём длинну интервала неопределённости, по достижению котрой коэффициент "D" считается найденным
    const double eps = 0.1;
    // задаём некоторое малое число "дельта", которое будем прибавлять слева и справа
    const double delta = 0.01;
    // правое и левое значение коэффициента "D" (аналог "х" в стандартном методе дихотомии)
    double D_left, D_right;
    // правое и левое значение функции
    double y_left, y_right;
    do { // выполняем алгоритм до тех пор, пока наш интервал не достигнет отметки 0,1
        D_left = 0.5 * (b + a) - delta; // вычисляем левое значение по формуле из стандартного метода дихотомии
        D_right = 0.5 * (b + a) + delta; // вычисляем правое значение по формуле из стандартного метода дихотомии
        y_left = recurssion_function(C, D_left); // вычисляем левое значение функции при левом коэффициенте "D"
        y_right = recurssion_function(C, D_right); // вычисляем правое значение функции при правом коэффициенте "D"
        // если правое значение функции больше левого значения, то:
        if (y_right > y_left) { 
            b = D_right; // меняем правую границу интервала на правый коэффициент "D"
        }
        else {
            a = D_left; // меняем левую границу интервала на левый коэффициент "D"
        }
    } while ((b - a) > eps);
    return ((b + a) / 2); // возвращаем коэффициент "D" (формула из стандартного метода дихотомии)
}

int main() {
    double a = -4.;
    double b = 2.;
    double A = 0.1;  // значения из варианта
    double c = 0.;
    double d = 3.;
    double iterator_x = (b - a) / N; // длинна шага
    int i = 0; // счётчик итераций
    std::random_device rand; //...
    std::mt19937 generation(rand()); //... эти три строчки позволяют выбрать случайным образом одно число типа double из интервала (-0.5, 0.5)
    std::uniform_real_distribution<double> interval(-0.5, 0.5); //...
    double C = Method_Passive_Search(); // находим коэффициент "С"
    double D = Method_dihotomia(-4, 2, C); // находим коэффициент "D"
    std::cout << "Found coefficients: " << "C = " << C << "; D = " << D << std::endl;
    for (double x2 = a; x2 < b; x2 += iterator_x) {
        // делаем зашумление рассчитанных точек (формула из методички)
        double t2 = c * x2 + d + A * interval(generation); 
        // записываем набор полученных пар в наш вектор значений
        function[i] = { x2, t2 };
        // переход на следующую итерацию
        i++;
    }
    // выводим полученный набор на экран
    std::cout << "Points with noise:" << std::endl;
    for (int i = 0; i < N; i++) {
        std::cout << "(" << function[i].first << ";" << function[i].second << ")" << std::endl;
    }
    return 0;
}
